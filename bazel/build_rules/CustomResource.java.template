package {JAVA_PACKAGE};

import {JAVA_PACKAGE}.{VERSION}.{KIND}Spec;
import {JAVA_PACKAGE}.{VERSION}.{KIND}Status;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;
import com.google.protobuf.util.JsonFormat;
import io.fabric8.kubernetes.api.builder.Function;
import io.fabric8.kubernetes.api.model.apiextensions.CustomResourceDefinition;
import io.fabric8.kubernetes.api.model.apiextensions.CustomResourceDefinitionBuilder;
import io.fabric8.kubernetes.client.CustomResource;
import io.fabric8.kubernetes.client.CustomResourceDoneable;
import io.fabric8.kubernetes.client.CustomResourceList;
import io.fabric8.kubernetes.client.KubernetesClient;
import io.fabric8.kubernetes.client.dsl.MixedOperation;
import io.fabric8.kubernetes.client.dsl.Resource;
import java.io.IOException;

/**
 * Boilerplate class for fabric8's CRD support. This class should be autogenerated.
 *
 * <p>Javascript serialization and deserialization is seriously challenging. Normally, you'd add the
 * jackson-datatype-protobuf module to Jackson and call it a day. However, that module relies on
 * being added to the jackson ObjectMapper, which is hidden inside the Kubernetes library. As a
 * confounding factor, the fabric8 library relies both on the Jackson tree structure (JsonNode) and
 * on the serialization. Work around the issue by using proto's JsonFormat to serialize/deserialize,
 * and then reconstruct the JsonNode tree from the serialized JSON. After all, what's a few wasted
 * cycles between friends?
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class {KIND} extends CustomResource {
  // TODO(swolter): This could be read from the CRD yaml, but
  // I was too lazy to figure out the Java resources for it.
  public static final CustomResourceDefinition DEFINITION =
      new CustomResourceDefinitionBuilder()
          .withNewMetadata()
          .withName("{PLURAL}.{KUBERNETES_GROUP}")
          .endMetadata()
          .withNewSpec()
          .withGroup("{KUBERNETES_GROUP}")
          .withVersion("{VERSION}")
          .withScope("Namespaced")
          .withNewNames()
          .withKind("{KIND}")
          .withPlural("{PLURAL}")
          .withSingular("{SINGULAR}")
          .endNames()
          .endSpec()
          .build();

  public static class Doneable{KIND} extends CustomResourceDoneable<{KIND}> {
    public Doneable{KIND}({KIND} {SINGULAR}, Function function) {
      super({SINGULAR}, function);
    }
  }

  public static class {KIND}List extends CustomResourceList<{KIND}> {}

  private static class {KIND}SpecSerializer extends StdSerializer<{KIND}Spec> {
    public {KIND}SpecSerializer() {
      this(null);
    }

    public {KIND}SpecSerializer(Class<{KIND}Spec> t) {
      super(t);
    }

    @Override
    public void serialize({KIND}Spec value, JsonGenerator jgen, SerializerProvider provider)
        throws IOException {
      if (value != null) {
        String json = JsonFormat.printer().includingDefaultValueFields().print(value);
        jgen.writeTree(new ObjectMapper().readTree(json));
      }
    }
  }

  private static class {KIND}StatusSerializer extends StdSerializer<{KIND}Status> {
    public {KIND}StatusSerializer() {
      this(null);
    }

    public {KIND}StatusSerializer(Class<{KIND}Status> t) {
      super(t);
    }

    @Override
    public void serialize({KIND}Status value, JsonGenerator jgen, SerializerProvider provider)
        throws IOException {
      if (value != null) {
        String json = JsonFormat.printer().print(value);
        jgen.writeTree(new ObjectMapper().readTree(json));
      }
    }
  }

  private static class {KIND}SpecDeserializer extends StdDeserializer<{KIND}Spec> {
    public {KIND}SpecDeserializer() {
      this(null);
    }

    public {KIND}SpecDeserializer(Class<?> vc) {
      super(vc);
    }

    @Override
    public {KIND}Spec deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
      String json = new ObjectMapper().writeValueAsString(jp.getCodec().readTree(jp));
      {KIND}Spec.Builder builder = {KIND}Spec.newBuilder();
      JsonFormat.parser().ignoringUnknownFields().merge(json, builder);
      return builder.build();
    }
  }

  private static class {KIND}StatusDeserializer extends StdDeserializer<{KIND}Status> {
    public {KIND}StatusDeserializer() {
      this(null);
    }

    public {KIND}StatusDeserializer(Class<?> vc) {
      super(vc);
    }

    @Override
    public {KIND}Status deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
      String json = new ObjectMapper().writeValueAsString(jp.getCodec().readTree(jp));
      {KIND}Status.Builder builder = {KIND}Status.newBuilder();
      JsonFormat.parser().ignoringUnknownFields().merge(json, builder);
      return builder.build();
    }
  }

  @JsonSerialize(using = {KIND}SpecSerializer.class)
  @JsonDeserialize(using = {KIND}SpecDeserializer.class)
  private {KIND}Spec spec = null;

  @JsonSerialize(using = {KIND}StatusSerializer.class)
  @JsonDeserialize(using = {KIND}StatusDeserializer.class)
  private {KIND}Status status = null;

  public {KIND}() {
    super(DEFINITION.getSpec().getNames().getKind());
    setApiVersion(DEFINITION.getSpec().getVersion());
  }

  public {KIND}Spec getSpec() {
    if (spec == null) {
      return {KIND}Spec.getDefaultInstance();
    }
    return spec;
  }

  public void setSpec({KIND}Spec spec) {
    this.spec = spec;
  }

  public {KIND}Status getStatus() {
    if (status == null) {
      return {KIND}Status.getDefaultInstance();
    }
    return status;
  }

  public void setStatus({KIND}Status status) {
    this.status = status;
  }

  @Override
  public String toString() {
    return "{KIND}{"
        + "apiVersion='"
        + getApiVersion()
        + '\''
        + ", metadata="
        + getMetadata()
        + ", spec="
        + spec
        + ", status="
        + status
        + '}';
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (!(o instanceof {KIND})) {
      return false;
    }
    {KIND} other = ({KIND})o;
    return getApiVersion().equals(other.getApiVersion())
        && getMetadata().equals(other.getMetadata())
        && getSpec().equals(other.getSpec())
        && getStatus().equals(other.getStatus());
  }

  @Override
  public int hashCode() {
    int result = 17;
    result = 31 * result + getApiVersion().hashCode();
    result = 31 * result + getMetadata().hashCode();
    result = 31 * result + getSpec().hashCode();
    result = 31 * result + getStatus().hashCode();
    return result;
  }

  /** Upload this {KIND} to the Kubernetes server, replacing an existing {KIND} with the same name. */
  public void replace(KubernetesClient client) {
    {KIND}.client(client)
        .inNamespace(getMetadata().getNamespace())
        .withName(getMetadata().getName())
        .replace(this);
  }

  public static MixedOperation<{KIND}, {KIND}List, Doneable{KIND}, Resource<{KIND}, Doneable{KIND}>> client(
      KubernetesClient client) {
    return client.customResources(DEFINITION, {KIND}.class, {KIND}List.class, Doneable{KIND}.class);
  }
}
